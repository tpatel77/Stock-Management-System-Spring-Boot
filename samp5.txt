import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

public class KeywordFilter {

    public static List<String> removeSentencesWithKeywords(List<String> section, List<String> keywords) {
        // Create a list to store updated sections
        List<String> updatedSection = new ArrayList<>();

        // Loop through each entry in the section
        for (String entry : section) {
            // Split the entry into sentences using a regex pattern
            String[] sentences = entry.split("(?<=\\.) ");

            // Filter sentences that do not contain any of the keywords
            StringBuilder filteredSentences = new StringBuilder();
            for (String sentence : sentences) {
                boolean containsKeyword = false;
                for (String keyword : keywords) {
                    if (sentence.toLowerCase().contains(keyword.toLowerCase())) {
                        containsKeyword = true;
                        break;
                    }
                }
                if (!containsKeyword) {
                    if (filteredSentences.length() > 0) {
                        filteredSentences.append(" ");
                    }
                    filteredSentences.append(sentence);
                }
            }

            // Add the filtered entry to the updated section if it is not empty
            String combinedEntry = filteredSentences.toString().trim();
            if (!combinedEntry.isEmpty()) {
                updatedSection.add(combinedEntry);
            }
        }

        return updatedSection;
    }

    public static void main(String[] args) {
        // Example usage
        List<String> section = List.of(
            "This is a test. It contains some keywords. This sentence is clean.",
            "Another test sentence. Keywords are not here."
        );
        List<String> keywords = List.of("keywords", "test");

        List<String> result = removeSentencesWithKeywords(section, keywords);
        System.out.println(result);
    }
}

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class DuplicateRemover {

    public static List<String> removeDuplicates(List<String> notesList) {
        // Set to track seen note contents
        Set<String> seen = new HashSet<>();
        // List to store unique notes
        List<String> uniqueNotes = new ArrayList<>();

        // Iterate through the notes list
        for (String note : notesList) {
            // Extract content after the first colon
            String[] parts = note.split(":", 2);
            String noteContent = parts.length > 1 ? parts[1].trim() : note.trim();

            // Check if the content is already seen
            if (!seen.contains(noteContent)) {
                seen.add(noteContent);
                uniqueNotes.add(note);
            }
        }

        return uniqueNotes;
    }

    public static void main(String[] args) {
        // Example usage
        List<String> notesList = List.of(
            "2023-01-01: Note content one",
            "2023-01-02: Note content two",
            "2023-01-03: Note content one" // Duplicate content
        );

        List<String> result = removeDuplicates(notesList);
        System.out.println(result);
    }
}



import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@SpringBootApplication
public class NoteSorterApplication {

    public static void main(String[] args) {
        SpringApplication.run(NoteSorterApplication.class, args);

        // Example usage
        List<String> notesList = List.of(
            "01/05/2022: Note one",
            "12/25/2021: Note two",
            "05/10/2023: Note three"
        );

        List<String> sortedNotes = sortByDate(notesList);
        System.out.println(sortedNotes);
    }

    public static List<String> sortByDate(List<String> notesList) {
        // List to store parsed dates and notes
        List<NoteWithDate> noteWithDateList = new ArrayList<>();

        // Pattern for MM/DD/YYYY format
        Pattern datePattern = Pattern.compile("\\b\\d{2}/\\d{2}/\\d{4}\\b");
        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");

        // Parse dates and add to the list
        for (String note : notesList) {
            Matcher matcher = datePattern.matcher(note);
            if (matcher.find()) {
                try {
                    LocalDate parsedDate = LocalDate.parse(matcher.group(), dateFormatter);
                    noteWithDateList.add(new NoteWithDate(parsedDate, note));
                } catch (DateTimeParseException e) {
                    // Skip notes with invalid dates
                }
            }
        }

        // Sort by date in reverse chronological order
        return noteWithDateList.stream()
                .sorted(Comparator.comparing(NoteWithDate::getDate).reversed())
                .map(NoteWithDate::getNote)
                .collect(Collectors.toList());
    }

    // Helper class to store notes with parsed dates
    static class NoteWithDate {
        private final LocalDate date;
        private final String note;

        public NoteWithDate(LocalDate date, String note) {
            this.date = date;
            this.note = note;
        }

        public LocalDate getDate() {
            return date;
        }

        public String getNote() {
            return note;
        }
    }
}



import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@SpringBootApplication
public class NoteCombinerApplication {

    public static void main(String[] args) {
        SpringApplication.run(NoteCombinerApplication.class, args);

        // Example usage
        List<String> notesList = List.of(
            "01/05/2022: Summary one",
            "01/05/2022: Summary two",
            "12/25/2021: Another summary",
            "No date summary"
        );

        List<String> combinedNotes = combineSummariesByDate(notesList);
        System.out.println(combinedNotes);
    }

    public static List<String> combineSummariesByDate(List<String> notesList) {
        // Map to group notes by date
        Map<String, List<String>> groupedNotes = new HashMap<>();
        Pattern datePattern = Pattern.compile("\\b\\d{2}/\\d{2}/\\d{4}\\b");

        // Group notes by date
        for (String note : notesList) {
            Matcher matcher = datePattern.matcher(note);
            String dateKey;
            if (matcher.find()) {
                dateKey = matcher.group();
                String content = note.split(":", 2)[1].trim();
                groupedNotes.computeIfAbsent(dateKey, k -> new ArrayList<>()).add(content);
            } else {
                dateKey = "NO_DATE";
                groupedNotes.computeIfAbsent(dateKey, k -> new ArrayList<>()).add(note);
            }
        }

        // Combine grouped notes into a single list
        List<String> combinedNotes = new ArrayList<>();
        for (Map.Entry<String, List<String>> entry : groupedNotes.entrySet()) {
            String date = entry.getKey();
            List<String> contents = entry.getValue();
            if ("NO_DATE".equals(date)) {
                combinedNotes.addAll(contents);
            } else {
                String combinedContent = contents.stream().collect(Collectors.joining(" and "));
                combinedNotes.add(date + ": " + combinedContent);
            }
        }

        return combinedNotes;
    }
}
