import logging
import sys
import json
from datetime import datetime
from src.common.models.CvsEventEnum import CvsEventEnum
from src.common.models.ResourceExecutionStats import ResourceExecutionStats
from src.summary.util.context_util import get_request_execution_ctx

class LoggerUtil:
    _logger = None
    LONGEST_EVENT = max(len(e.value) for e in CvsEventEnum)

    @classmethod
    def initialize(cls):
        if cls._logger is None:
            # Configure logging
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.StreamHandler(sys.stdout),
                    logging.FileHandler('logs/application.log')
                ]
            )
            cls._logger = logging.getLogger('cvs_event_logger')

    @classmethod
    def _format_field(cls, name: str, value: str) -> str:
        """Format a field with consistent spacing"""
        return f'"{name}": "{value}"'

    @classmethod
    def _format_object_field(cls, name: str) -> str:
        """Format an object field with consistent spacing"""
        return f'"{name}": {{}}'

    @classmethod
    def _format_number_field(cls, name: str, value: int) -> str:
        """Format a number field with consistent spacing"""
        return f'"{name}": {value}'

    @classmethod
    def _get_formatted_message(cls, event_type: CvsEventEnum, message: str) -> str:
        """Get formatted message with execution context"""
        try:
            res = get_request_execution_ctx()
            if res is None:
                res = ResourceExecutionStats()

            # Format each field consistently
            fields = [
                cls._format_field("CVSEVENT", event_type.value.ljust(cls.LONGEST_EVENT)),
                cls._format_field("grid", res.grid or ""),
                cls._format_field("desc", message),
                cls._format_object_field("metrics"),
                cls._format_object_field("tags"),
                cls._format_object_field("methodStats"),
                cls._format_field("statusCde", ""),
                cls._format_field("statusMsg", ""),
                cls._format_number_field("httpStatusCde", 200),
                cls._format_field("httpMethod", "POST"),
                cls._format_number_field("reqLength", 16),
                cls._format_field("startTime", datetime.now().isoformat()),
                cls._format_field("appName", "spl-domain-py-notessummary")
            ]
            
            # Join fields with comma and space
            return "{" + ", ".join(fields) + "}"
            
        except Exception as e:
            # Fallback with same formatting
            fields = [
                cls._format_field("CVSEVENT", event_type.value.ljust(cls.LONGEST_EVENT)),
                cls._format_field("grid", ""),
                cls._format_field("desc", message),
                cls._format_field("startTime", datetime.now().isoformat()),
                cls._format_field("appName", "spl-domain-py-notessummary")
            ]
            return "{" + ", ".join(fields) + "}"

    @classmethod
    def logMessage(cls, event: CvsEventEnum, message: str) -> None:
        """Log a message with the given event type and execution context"""
        if cls._logger is None:
            cls.initialize()
        
        formatted_message = cls._get_formatted_message(event, message)
        
        match event:
            case CvsEventEnum.ERROR:
                cls._logger.error(formatted_message)
            case CvsEventEnum.DEBUG:
                cls._logger.debug(formatted_message)
            case _:  # ENTRY, EXIT, INFO
                cls._logger.info(formatted_message)




############################################################
import logging
import sys
import json
import inspect
from datetime import datetime
from src.common.models.CvsEventEnum import CvsEventEnum
from src.common.models.ResourceExecutionStats import ResourceExecutionStats
from src.summary.util.context_util import get_request_execution_ctx

# Custom LoggerAdapter to add the parent's method name into the log record.
class ParentLoggerAdapter(logging.LoggerAdapter):
    def process(self, msg, kwargs):
        # The parent method is typically the caller of the LoggerUtil.logMessage() method.
        parent_frame = inspect.stack()[2]
        parent_method = parent_frame.function
        extra = kwargs.get('extra', {})
        extra['parentMethod'] = parent_method
        kwargs['extra'] = extra
        return msg, kwargs

class LoggerUtil:
    _logger = None
    LONGEST_EVENT = max(len(e.value) for e in CvsEventEnum)

    @classmethod
    def initialize(cls):
        if cls._logger is None:
            # Configure logging with file name and parent method included.
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(filename)s:%(lineno)d] [Parent: %(parentMethod)s] - %(message)s',
                handlers=[
                    logging.StreamHandler(sys.stdout),
                    logging.FileHandler('logs/application.log')
                ]
            )
            # Wrap our logger in the ParentLoggerAdapter so that each log record includes the parent method.
            cls._logger = ParentLoggerAdapter(logging.getLogger('cvs_event_logger'), {})

    @classmethod
    def _format_field(cls, name: str, value: str) -> str:
        """Format a field with consistent spacing"""
        return f'"{name}": "{value}"'

    @classmethod
    def _format_object_field(cls, name: str) -> str:
        """Format an object field with consistent spacing"""
        return f'"{name}": {{}}'

    @classmethod
    def _format_number_field(cls, name: str, value: int) -> str:
        """Format a number field with consistent spacing"""
        return f'"{name}": {value}'

    @classmethod
    def _get_formatted_message(cls, event_type: CvsEventEnum, message: str) -> str:
        """Get formatted message with execution context"""
        try:
            res = get_request_execution_ctx()
            if res is None:
                res = ResourceExecutionStats()

            # Format each field consistently
            fields = [
                cls._format_field("CVSEVENT", event_type.value.ljust(cls.LONGEST_EVENT)),
                cls._format_field("grid", res.grid or ""),
                cls._format_field("desc", message),
                cls._format_object_field("metrics"),
                cls._format_object_field("tags"),
                cls._format_object_field("methodStats"),
                cls._format_field("statusCde", ""),
                cls._format_field("statusMsg", ""),
                cls._format_number_field("httpStatusCde", 200),
                cls._format_field("httpMethod", "POST"),
                cls._format_number_field("reqLength", 16),
                cls._format_field("startTime", datetime.now().isoformat()),
                cls._format_field("appName", "spl-domain-py-notessummary")
            ]
            
            # Join fields with comma and space
            return "{" + ", ".join(fields) + "}"
            
        except Exception as e:
            # Fallback with same formatting
            fields = [
                cls._format_field("CVSEVENT", event_type.value.ljust(cls.LONGEST_EVENT)),
                cls._format_field("grid", ""),
                cls._format_field("desc", message),
                cls._format_field("startTime", datetime.now().isoformat()),
                cls._format_field("appName", "spl-domain-py-notessummary")
            ]
            return "{" + ", ".join(fields) + "}"

    @classmethod
    def logMessage(cls, event: CvsEventEnum, message: str) -> None:
        """Log a message with the given event type and execution context"""
        if cls._logger is None:
            cls.initialize()
        
        formatted_message = cls._get_formatted_message(event, message)
        
        match event:
            case CvsEventEnum.ERROR:
                cls._logger.error(formatted_message)
            case CvsEventEnum.DEBUG:
                cls._logger.debug(formatted_message)
            case _:  # ENTRY, EXIT, INFO
                cls._logger.info(formatted_message)




import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;

import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

public class YamlGenerator {

    public static void main(String[] args) throws IOException {
        // 1. Top‐level map
        Map<String, Object> root = new LinkedHashMap<>();
        root.put("name", "Run CI Pipeline");

        // 2. on.push.branches and paths-ignore
        Map<String, Object> on = new LinkedHashMap<>();
        Map<String, Object> push = new LinkedHashMap<>();
        push.put("branches", Arrays.asList("main", "REL_*", "DEV_*"));
        push.put("paths-ignore", Arrays.asList(
                "deploy-configs/**",
                "README.md",
                ".github/workflows/cd.yaml"
        ));
        on.put("push", push);
        root.put("on", on);

        // 3. jobs.cicd
        Map<String, Object> jobs = new LinkedHashMap<>();
        Map<String, Object> cicd = new LinkedHashMap<>();

        cicd.put("uses", "cvs-health-source-code/gha_workflow_actions/.github/workflows/gradle_docker.yaml@latest");
        cicd.put("secrets", "inherit");

        // 4. with: key/value map under jobs.cicd
        Map<String, Object> with = new LinkedHashMap<>();
        with.put("JAVA_VERSION", "21.0.3");
        with.put("JAVA_BUILD_COMMAND", "./gradlew build");
        with.put("JAVA_LINT_COMMAND", "echo \"Lint\"");
        with.put("SCA_TOOL", "snyk");            // Change to snyk when snyk issue is resolved --xray
        with.put("SAST_TOOL", "snyk");
        with.put("CONTAINER_SCAN_TOOL", "snyk");
        with.put("SNYK_ORG", "cvs-health-default");
        with.put("ALL_PROJECTS_SNYK", "true");    // Validate
        with.put("JAVA_DEPS_COMMAND", "./gradlew clean --refresh-dependencies");
        with.put("DOCKER_REGISTRY_NAME", "cvsdigital-docker/specialty");
        with.put("DOCKER_PUBLISH", Boolean.TRUE);

        cicd.put("with", with);

        jobs.put("cicd", cicd);
        root.put("jobs", jobs);

        // 5. Configure YAML options to match your desired formatting
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        options.setIndent(2);
        options.setPrettyFlow(true);
        // Keep quotes around strings that need them
        Representer representer = new Representer();
        representer.getPropertyUtils().setSkipMissingProperties(true);

        Yaml yaml = new Yaml(representer, options);

        // 6. Write out to file
        try (FileWriter writer = new FileWriter("workflow.yaml")) {
            yaml.dump(root, writer);
        }

        System.out.println("Generated workflow.yaml");
    }
}













import java.io.FileWriter;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

public class WorkflowYamlWriter {

    /**
     * Generates the GitHub Actions workflow YAML for “App Deployment”,
     * using the provided map of filter-names to glob-patterns.
     *
     * @param filters map where
     *                key   = the filter ID (e.g. "spl-rke-west-sit1_v1")
     *                value = the glob to watch (e.g. "**/deploy-configs/spl-rke-west-sit1/values/v1.yaml")
     */
    public static String generateWorkflowYaml(Map<String, String> filters) {
        StringBuilder sb = new StringBuilder();

        sb.append("name: App Deployment\n");
        sb.append("on:\n");
        sb.append("  workflow_dispatch:\n");
        sb.append("  push:\n");
        sb.append("    branches:\n");
        sb.append("      #- GitHub-Actions\n");
        sb.append("      #- develop-*\n");
        sb.append("      #- dev*\n");
        sb.append("      #- feature*\n");
        sb.append("      #- main\n");
        sb.append("    paths:\n");
        sb.append("      - '**/deploy-configs/**/v1.yaml'\n\n");

        sb.append("permissions:\n");
        sb.append("  id-token: write\n");
        sb.append("  contents: read\n");
        sb.append("  pull-requests: write\n\n");

        sb.append("jobs:\n");
        sb.append("  detect-changes:\n");
        sb.append("    runs-on:\n");
        sb.append("      group: cvs-linux-self-hosted\n\n");
        sb.append("    outputs:\n");
        sb.append("      ENV_NAME: ${{ steps.set-env.outputs.ENV_NAME }}\n");
        sb.append("      HELM_FILE_VERSION: ${{ steps.set-env.outputs.HELM_FILE_VERSION }}\n\n");
        sb.append("    steps:\n");
        sb.append("      - name: Checkout\n");
        sb.append("        uses: actions/checkout@v4\n");
        sb.append("        with:\n");
        sb.append("          fetch-depth: 0\n\n");
        sb.append("      - name: Detect changes\n");
        sb.append("        id: changes\n");
        sb.append("        uses: dorny/paths-filter@v3\n");
        sb.append("        with:\n");
        sb.append("          base: ${{ github.ref_name }}\n");
        sb.append("          filters: |\n");
        // insert all filter entries here
        filters.forEach((filterName, globPattern) -> {
            sb.append("            ")
              .append(filterName)
              .append(":\n");
            sb.append("              - '")
              .append(globPattern)
              .append("'\n");
        });
        sb.append("\n");
        sb.append("      - name: Set Environment Variables\n");
        sb.append("        id: set-env\n");
        sb.append("        run: |\n");
        sb.append("          \n");
        // build the if/elif chain
        boolean first = true;
        for (String filterName : filters.keySet()) {
            if (first) {
                sb.append("          if [ \"${{ steps.changes.outputs.")
                  .append(filterName)
                  .append(" }}\" = \"true\" ]; then\n");
                first = false;
            } else {
                sb.append("          elif [ \"${{ steps.changes.outputs.")
                  .append(filterName)
                  .append(" }}\" = \"true\" ]; then\n");
            }
            // derive ENV (strip after underscore if you like, or just reuse the key)
            String envName = filterName.contains("_")
                             ? filterName.substring(0, filterName.indexOf('_'))
                             : filterName;
            String version = filterName.contains("_")
                             ? filterName.substring(filterName.lastIndexOf('_') + 1)
                             : "v1";
            sb.append("              echo \"ENV_NAME=")
              .append(envName)
              .append("\" >> $GITHUB_OUTPUT\n");
            sb.append("              echo \"HELM_FILE_VERSION=")
              .append(version)
              .append("\" >> $GITHUB_OUTPUT\n");
        }
        sb.append("          fi\n\n");

        sb.append("  deploy:\n");
        sb.append("    uses: cvs-health-source-code/gitops-cd-workflow/.github/workflows/helm-deploy.yaml@v1\n");
        sb.append("    needs: [ detect-changes ]\n");
        sb.append("    secrets: inherit\n");
        sb.append("    with:\n");
        sb.append("      app-name: \"spl-domain-eventsprocessor-fmh\"\n");
        sb.append("      environment: ${{ needs.detect-changes.outputs.ENV_NAME }}\n");
        sb.append("      helm-template-repo: ${{ vars.HELM_TEMPLATE_REPO }}\n");
        sb.append("      helm-file-version: ${{ needs.detect-changes.outputs.HELM_FILE_VERSION }}\n");
        sb.append("      helm-template-branch: ${{ vars.HELM_TEMPLATE_BRANCH }}\n");
        sb.append("      # helm-template-branch: v1.0.3\n");
        sb.append("      canary-weight: \"0\"\n");

        return sb.toString();
    }

    public static void main(String[] args) throws IOException {
        // example customization:
        Map<String, String> myFilters = new LinkedHashMap<>();
        myFilters.put("spl-rke-west-sit1_v1", "**/deploy-configs/spl-rke-west-sit1/values/v1.yaml");
        myFilters.put("spl-rke-west-sit2_v1", "**/deploy-configs/spl-rke-west-sit2/values/v1.yaml");
        // you could add more (or remove) entries at runtime

        String yaml = generateWorkflowYaml(myFilters);
        System.out.println(yaml);

        // optionally write to file:
        try (FileWriter fw = new FileWriter("app-deploy-workflow.yaml")) {
            fw.write(yaml);
        }
    }
}

